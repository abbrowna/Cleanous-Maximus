/*
 Name:		Bincode.ino
 Created:	3/10/2017 4:23:02 PM
 Author:	Anthony_Brown
*/

#include <Servo.h>
#include <CurieTimerOne.h>
#include <SPI.h>
#include <SD.h>
#include <Arduino.h>
#include <aux_regs.h>
#include <conf.h>
#include <scss_registers.h> //This gives us the register adresses for the quark.
#include <time.h> //this will be used for randomisation
#include <stdio.h>

//AUDIO TYPES
#define passerby 1
#define approach 2
#define deposit 3
#define leaving 4

// AUDIO AND TIMER VARIABLES
uint32_t pwmChan; //Will be set to quark timer 0 for the pwm DAC
const uint32_t clock_freq = 32000000; //The frequncy of the Quark clock.(32Mhz)
const uint32_t pwm_frequency = 400000; //The desired frequency of the pwm DAC
const int sampler_input_pin = 8; //This pin will receive the sampling interrupt generated by Quark. Timer 4
const int sampler_output_pin = 9;//This is th pin through which the timer will generate the sampling interrupt.
//sampler_input_pin and sampler_output_pin should therefore be shorted.
//This is the amount of data to be fetched from the sd card for each read.
const int BUFFERSIZE = 256;
const int speaker_pin = 3; //Pin to which speaker will be connected

//This struct will hold information related to the wav file that's being read.
typedef struct
{
	int format;
	int sample_rate;
	int bits_per_sample;
}wave_format;
wave_format wave_info;

volatile unsigned char note = 0; //holds the current voltage value to be sent to the ADC
volatile int period;
unsigned char header[44]; //holds the wav file header
unsigned char buffer1[BUFFERSIZE], buffer2[BUFFERSIZE]; //Two cycling buffers which contain the wav data.
char file_name[30]; //wav file name.
unsigned long file_size; //will store the size of the audio file in bytes.

char play_buffer = 0; //keeps track of which bufferis currently being used
char new_buffer_ready = 0; //Flag used by loop code to tell the interrupt that new data is ready in the buffer.
volatile unsigned int byte_count = 0; //keeps track of the read position in the current buffer.
volatile char need_new_data = 0; //Flag used by interrupt to tell 'Loop' code that a buffer is empty and needs to be refilled.
bool ramp_down = 0;
volatile int ramp_factor = 0; // This will be increased progressively to alter playback volume at end of file.
File audio;

//SENSOR VARIABLES
volatile int pass_count = 0;
int pingleft = 4;
int pingright = 13;
int pingcenter = 3;
int PIRpin = 2;
int throwPIR = 7;
int levelping = 0;
volatile unsigned long lastapproach = 0;
volatile unsigned long lastthrow = 0;
volatile bool throwin = 0;
struct proxi_multi
{
	int distance;
	int sensor;
};


//EYE VARIABLES
const int pan = 3;
const int tilt = 6;
Servo panservo;
Servo tiltservo;

void setup() {
	Serial.begin(115200);
	while (!Serial) {
	}
	//if (!SD.begin())
	//{
	//	Serial.println("Failed to initiallize SD");
	//	return;
	//}
	//else
		Serial.println("SD initialized succesfully");
	//attatch an interrupt to the PIR that will trigger a response from the bin.
	attachInterrupt(digitalPinToInterrupt(PIRpin), motiondetect, RISING);
	attachInterrupt(digitalPinToInterrupt(throwPIR), throwdetect, RISING);
	panservo.attach(pan);
	tiltservo.attach(tilt);
}

void loop() {
	for (int i = 0; i < 180; i++)
	{
		panservo.write(i);
		tiltservo.write(i);
		delay(20);
	}
	for (int i = 180; i > 0; i--)
	{
		panservo.write(i);
		tiltservo.write(i);
		delay(20);
	}
}

//this function selects aan audiofile from the passed category to be played at random
const char* audio_select(int audiotype)
{
	int filecount = 0;
	while (filecount <= 99)
	{
		char name[9] = { '\0' };
		sprintf(name, "%d%.2d.wav", audiotype, filecount);
		if (SD.exists(name))
			filecount++;
		else
			break;
	}
	static char filename[8] = { '\0' };
	randomSeed(millis());
	int audionum = random(0, filecount);
	sprintf(filename, "%d%.3d.wav", audiotype, audionum);
	const char *str = filename;
	return str;
}

//Setup the constant parameters of a square wave on quark timer 0
void pwm_setup(int pin)
{
	uint32_t offset; //Added onto a base address to give required register Address address
	PinDescription *p = &g_APinDescription[pin];
	//convert pin to channel:
	if (p->ulPwmChan == INVALID)
	{
		Serial.println("Invalid pin Number for timer");
		return; //The pin you gave is not pwm enabled.
	}
	pwmChan = p->ulPwmChan;
	SET_PIN_PULLUP(p->ulSocPin, 0);
	SET_PIN_MODE(p->ulSocPin, PWM_MUX_MODE);
	p->ulPinMode = PWM_MUX_MODE;

	//Configure for pwm mode, no interrupts, free running, enabled
	offset = (pwmChan * QRK_PWM_N_REGS_LEN) + QRK_PWM_N_CONTROL;
	MMIO_REG_VAL(QRK_PWM_BASE_ADDR + offset) =
		QRK_PWM_CONTROL_PWM_OUT |		//sets to pwm mode
		QRK_PWM_CONTROL_INT_MASK |		//disables interupts for now
		QRK_PWM_CONTROL_MODE_PERIODIC |	//user defined count
		QRK_PWM_CONTROL_ENABLE;			//enable timer
}

void sampleISR() //this ISR is called to retrieve and play the next sample from the audio file.
{
	noInterrupts(); //Disable interrupts

	//Check to see if we've read all of the data in the current buffer
	if (byte_count == BUFFERSIZE)
	{
		need_new_data = 1;//Set a flag to tell the 'loop' code to refill the current buffer.
		byte_count = 0; //Reset the count
						//Check to see if new data exists in the alternate buffer
		if (new_buffer_ready == 1)
		{
			//If new data is available, reassign the play buffer.
			if (play_buffer == 0)
				play_buffer = 1;
			else
				play_buffer = 0;
		}
		else
		{
			//If no new data is available then wait for it!
			interrupts();
			return;
		}
	}
	//Find out which buffer is being used, and get data from it.
	if (play_buffer == 0)
		note = buffer1[byte_count];
	else
		note = buffer2[byte_count];
	//Increase the byte_count since we've taken the current data.
	byte_count++;
	if (ramp_down)
	{
		ramp_factor += 10;
	}
	//Update the pwm with the retrieved value from the play buffer having subtracted the ramp_factor
	if (note - ramp_factor <= 0)
		note = 0; //we dont want a negative amplitude.
	else
		note = note - ramp_factor;
	pwm_update(note); //The note retrieved is passed as the duty cycle to the pwm timer.
	interrupts();//Re-enable interrupts	
}

//This function updates the quark timer 0 with required duty
void pwm_update(int duty)
{
	uint32_t offset; //Added onto a base address to give required register Address address

	double ticks = clock_freq / pwm_frequency; //Number of 32mhz periods for one period of desired freq
	uint32_t high_time = round(ticks * duty / 255.00);
	uint32_t low_time = ticks - high_time;
	//This function will be called in an ISR hence avoid slow serial Comunication.
	//Serial.print(low_time);
	//Serial.print("::");
	//Serial.println(high_time);
	offset = (pwmChan * QRK_PWM_N_REGS_LEN) + QRK_PWM_N_LOAD_COUNT1;
	MMIO_REG_VAL(QRK_PWM_BASE_ADDR + offset) = low_time; //put low time into load count 1
	offset = (pwmChan * QRK_PWM_N_REGS_LEN) + QRK_PWM_N_LOAD_COUNT2; //put high_time into load count 2
	MMIO_REG_VAL(QRK_PWM_BASE_ADDR + offset) = high_time;
}

//setup another quark timer to generate an interrupt at the Audio sample rate
//sample_rate in Hz & the pin through whih the interrupt will be generated.
void setup_timer(int sample_rate, int pin)
{
	double interval = 1000000.00 / sample_rate;
	Serial.print("sample_rate count interval = ");
	Serial.println(interval);
	uint32_t offset;	//store the value to add onto the base address.
	PinDescription *p = &g_APinDescription[pin];
	uint32_t timerChan = p->ulPwmChan;

	//Configure for timer mode, with interrupts, free running , enabled.
	offset = (timerChan * QRK_PWM_N_REGS_LEN) + QRK_PWM_N_CONTROL;
	MMIO_REG_VAL(QRK_PWM_BASE_ADDR + offset) =
		QRK_PWM_CONTROL_MODE_PERIODIC |	//user defined count
		QRK_PWM_CONTROL_ENABLE;			//enable timer

	//set timer count. The timer will expire at this point and call the interrupt
	uint32_t count = interval * clock_freq / 1000000; //number of 32Mhz ticks to count
	Serial.println(count);
	offset = (timerChan * QRK_PWM_N_REGS_LEN) + QRK_PWM_N_LOAD_COUNT1;
	MMIO_REG_VAL(QRK_PWM_BASE_ADDR + offset) = count;	//write count to LOAD_COUNT1
	//connect timer to the pin through which it will send the signal
	SET_PIN_PULLUP(p->ulSocPin, 0);
	SET_PIN_MODE(p->ulSocPin, PWM_MUX_MODE);
	p->ulPinMode = PWM_MUX_MODE;

	pinMode(sampler_input_pin, INPUT);
	//Attatch an SampleISR to the sampler input pin.
	attachInterrupt(digitalPinToInterrupt(sampler_input_pin), sampleISR, CHANGE);
}

//Read the WAV file header
void read_wav_header(unsigned char * header)
{
	char field[2];

	audio.read(header, 44);
	//Extract the Sample Rate field from the header
	sprintf(field, "%x%x", header[25], header[24]);
	wave_info.sample_rate = (int)strtol(field, NULL, 16);
	//Extract the audio format from the header
	sprintf(field, "%x%x", header[21], header[20]);
	wave_info.format = (int)strtol(field, NULL, 16);
	//Extract the bits per sample from the header
	sprintf(field, "%x%x", header[35], header[34]);
	wave_info.bits_per_sample = (int)strtol(field, NULL, 16);
	Serial.print("bits per sample = ");
	Serial.println(wave_info.bits_per_sample);
	Serial.print("sample_rate = ");
	Serial.println(wave_info.sample_rate);
	Serial.print("bits per sample = ");
	Serial.println(wave_info.bits_per_sample);
	return;
}

void playaudio(const char *filename) {
	detachInterrupt(PIRpin); //detach the PIR interrupt so as to prevent it interrupting playback
	pwm_setup(speaker_pin); 	//start the pwm wave on a certain pin.
	noInterrupts(); //disable interrupts for now, till we are ready to start taking samples.

	int bytes_read = 0; //Keeps track of how many bytes are read when accessing a file on the SD card.
	//open the file
	audio = SD.open(filename);
	//confirm if the file was found and check it's size. 
	if (audio)
	{
		file_size = audio.size();
		Serial.print(filename);
		Serial.print("opened succesfully. File size = ");
		Serial.println(file_size);
	}
	else {
		Serial.println("No such file");
		return;
	}
	read_wav_header(header);
	unsigned long ramp_point = audio.size() - 256;
	//start the sample rate timer
	setup_timer(wave_info.sample_rate, sampler_output_pin);
	//set the initial play buffer, and grab the initial data from the SD card
	play_buffer = 0;
	bytes_read = audio.read(buffer1, BUFFERSIZE);
	bytes_read = audio.read(buffer2, BUFFERSIZE);
	//Enable interrupts to start the wav playback.
	interrupts();
	while (1)
	{
		if (need_new_data == 1) //need_new_data flag is set by ISR to indicate a buffer is empty and should be refilled
		{
			need_new_data = 0; //clear the flag.
			if (play_buffer == 0) //play buffer indicates which buffer is now empty
			{
				//Get the next BUFFERSIZE bytes from the file.
				bytes_read = audio.read(buffer1, BUFFERSIZE);
			}
			else
			{
				//get the next BUFFERSIZE bytes from the file.
				bytes_read = audio.read(buffer2, BUFFERSIZE);
			}
			new_buffer_ready = 1; //new_buffer_ready flag tells the ISR that the buffer has beed filled.
			//Check if we are near the end of the file and ramp down if we are.
			if (audio.position() >= ramp_point && !ramp_down)
			{
				ramp_down = 1;//Raise the ramp_down flag.
			}
			//If file_read returns 0 or -1 file is over. Close the file.
			if (bytes_read <= 0)
			{
				noInterrupts();
				audio.close();
				Serial.print("playback over:");
			}
		}
	}
	attachInterrupt(digitalPinToInterrupt(PIRpin), motiondetect, RISING); //reattatch the PIR interrupt.
}

//checks the proximity on a specifiec sensor.
int proximity(int pingPin)
{
	int sum = 0;
	unsigned long duration;
	noInterrupts(); //disable possible interrupts from the PIR
	for (int i = 1; i <= 3; i++)
	{
		pinMode(pingPin, OUTPUT);
		digitalWrite(pingPin, LOW);
		delayMicroseconds(2);
		digitalWrite(pingPin, HIGH);
		delayMicroseconds(5);
		digitalWrite(pingPin, LOW);
		pinMode(pingPin, INPUT);
		duration = pulseIn(pingPin, HIGH);
		sum = sum + (duration / 29 / 2);
		delay(100);
	}
	interrupts(); //reanable interrupts
	return sum / 3;
}


//checks the proximity on all three sensors and returns the shortest distanceof the three
struct proxi_multi proximity_multiple()
{
	struct proxi_multi d;
	int prox1 = proximity(pingright);
	int prox2 = proximity(pingcenter);
	int prox3 = proximity(pingleft);
	int min = prox1;
	d.sensor = prox1;
	if (prox2 < min) {
		min = prox2;
		d.sensor = prox2;
	}
	if (prox3 < min) {
		min = prox3;
		d.sensor = prox3;
	}
	d.distance = min;
	return d;
}

//This in an ISR called every time the the outer PIR detects motion after a period of inactivity.
 void motiondetect()  
{
	 struct proxi_multi minsurround = proximity_multiple();
	 if (minsurround.distance < 50)
	 {
		 //either approaching the bin, near the bin or walking away from the bin.
		 if (millis() - lastapproach > 10000 && !throwin)		//the are approaching
		 {
			 playaudio(audio_select(approach));
			 lastapproach = millis();
		 }
		 else if (millis() - lastapproach > 3000 && throwin)	//they are leaving.
		 { 
			 playaudio(audio_select(leaving));
			 throwin = 0;
		 }
	 }
	 else if (minsurround.distance > 50)
	 {
		 //someone just passed by. Say hello if they are the 5th person to do so.
		 pass_count++;
		 if (pass_count == 5)
		 {
			 playaudio(audio_select(passerby));
			 pass_count = 0;
		 }
	 }
}

//Called when inner PIR detects motion.
 void throwdetect()	
 {
	 if ((millis() - lastthrow) > 2000)
	 {
		 playaudio(audio_select(deposit));
		 throwin = 1;
		 lastthrow = millis();
	 }
 }

//(panangle;tiltangle;ms between angles)
 void eye_move(int pan, int tilt, int speed = 0) 
 {
	 int lastpan = panservo.read();
	 int lasttilt = tiltservo.read();
	 int pandiff = abs(pan - lastpan);
	 int tiltdiff = abs(tilt - tiltdiff);
	 if (tiltdiff >= pandiff)
	 {
		 float ratio = pandiff/tiltdiff;
		 if (tilt >= lasttilt)
		 {
			 if (pan >= lastpan)
			 {
				 for (int t = lasttilt , float p = lastpan; t < tilt; t++,p += ratio)
				 {
					 tiltservo.write(t);
					 panservo.write(round(p));
					 delay(speed);
				 }
			 }
			 else if (pan < lastpan)
			 {
				 for (int t = lasttilt, float p = lastpan; t < tilt; t++, p -= ratio)
				 {
					 tiltservo.write(t);
					 panservo.write(p);
					 delay(speed);
				 }
			 }
		 }
		 else if (tilt < lasttilt)
		 {
			 if (pan >= lastpan)
			 {
				 for (int t = lasttilt, float p = lastpan; t > tilt; t--, p += ratio)
				 {
					 tiltservo.write(t);
					 panservo.write(round(p));
					 delay(speed);
				 }
			 }
			 else if (pan < lastpan)
			 {
				 for (int t = lasttilt, float p = lastpan; t > tilt; t--, p -= ratio)
				 {
					 tiltservo.write(t);
					 panservo.write(round(p));
					 delay(speed);
				 }
			 }
		 }
	 }
	 else if (pandiff > tiltdiff)
	 {
		 float ratio = tiltdiff / pandiff;
		 if (pan >= lastpan)
		 {
			 if (tilt >= lasttilt)
			 {
				 for (int p = lastpan, float t = lasttilt; p < pan; p++, t += ratio)
				 {
					 panservo.write(p);
					 tiltservo.write(round(t));
					 delay(speed);
				 }
			 }
			 else if (tilt < lasttilt)
			 {
				 for (int p = lastpan, float t = lasttilt; p < pan; p++, t -= ratio)
				 {
					 panservo.write(p);
					 tiltservo.write(round(t));
					 delay(speed);
				 }
			 }
		 }
		 else if (pan < lastpan)
		 {
			 if (tilt > lasttilt)
			 {
				 for (int p = lastpan, float t = lasttilt; p > pan; p--, t += ratio)
				 {
					 panservo.write(p);
					 tiltservo.write(round(t));
					 delay(speed);
				 }
			 }
			 else if (tilt < lasttilt)
			 {
				 for (int p = lastpan, float t = lasttilt; p > pan; p--, t -= ratio)
				 {
					 panservo.write(p);
					 tiltservo.write(round(t));
					 delay(speed);
				 }
			 }
		 }
	 }
 }
 

